Why concurrent programming is difficult
----------------------------------------

- InterruptedException :- Thrown during calling join method and sleep method on thread
- ConcurrentModificationException : two or more threads trying to access same variable that isn’t thread safe
- Thread Blocking


THE ACTOR MODEL
--------------------
- Different way of concurrent programming

Example : Get the next probable prime number

- **What is an Actor ?**
    
    An object with number of key features that has **‘Name’** and **‘Path**
    
    **Path** allows has to uniquely identify location of actor
    
    **Message queue :** When one actor tells another actor something what happens is that the message, the information being told from one actor to another gets put into that actor queue.
    
    **Actors Behaviour :** that tells what to do when an actor receives a message. It could ignore, respond to it, run some code
    
    → it takes message from the queue and process it one at a time. so the messages that actor can send or receive are not going to be only strings or numbers. they can be any class that is serialisable.
  
  - **Why does this model work ?**
    - Each actor has its own thread
    - Actors won’t share data → meaning each actor has its own state, its own data but it wont share that data with any other actor ************so two actor can’t have reference to the same memory space on heap.************ Any variables contained in an actor’s memory space is going to be isolated to that single actor. Because each actor has its own thread there is no sharing of data across threads. ********************************************************→NO ISSUE WITH THREAD SAFETY********************************************************
    - Actors can send data to each other through messages → Messages must be immutable
    - Messages are processed one at a time.  → ******************************************************************this saves from Interrupted exception →******************************************************************because an actor can only access the data in its own state, and it wont run any code until the processing is done so there is no chance of Interrupted exception. → Also prevent from **********************************ConcurrentAccess**********************************



What is AKKA
---------------
Akka is an open-source toolkit and runtime for building highly concurrent, distributed, and fault-tolerant systems. It's written in Scala and is designed to help developers build reactive applications that can handle large numbers of concurrent users and support the principles of the actor model.

The actor model is a computational model that treats actors as the fundamental unit of computation. An actor is an autonomous computational entity that communicates with other actors by exchanging messages. Akka implements the actor model and provides a set of abstractions that make it easy to build actor-based systems.

Akka provides two types of APIs: **Classic and Typed**. Classic API is the original API that has been used in Akka since its first release. It's based on the actor model and provides a set of primitives for building actor-based systems. The **Classic API is based on mutable state and shared memory**, which can make it more challenging to reason about concurrency and make it harder to write correct and scalable applications.

The **Typed API is a newer API that was introduced in Akka 2.6. I**t provides a type-safe and functional API that makes it easier to reason about concurrency and write correct and scalable applications. The **Typed API is based on immutable state and message passing**, which makes it easier to write concurrent code that is easy to reason about and understand. The Typed API also provides a set of higher-level abstractions, such as Akka Persistence, that make it easier to build more complex systems.

In summary, Akka is an open-source toolkit and runtime for building highly concurrent, distributed, and fault-tolerant systems. It provides two types of APIs, Classic and Typed, which are based on the actor model and provide abstractions for building actor-based systems. The Typed API is a newer and more modern API that provides a type-safe and functional API that makes it easier to reason about concurrency and write correct and scalable applications.

```xml
<dependency>
    <groupId>com.typesafe.akka</groupId>
    <artifactId>akka-actor-typed_**2.13**</artifactId> <!--Scala version-->
    <version>2.6.3</version><!--AKKA Version -->
</dependency>
<dependency>
    <groupId>com.typesafe.akka</groupId>
    <artifactId>akka-actor-testkit-typed_**2.13**</artifactId>
    <version>2.6.3</version>
</dependency>

```

```xml
<!-- logging-->
<dependency>
  <groupId>ch.qos.logback</groupId>
  <artifactId>logback-classic</artifactId>
  <version>1.2.3</version>
</dependency>
```

- **WHAT WE NEED TO DO?**
    
    Akka handles most of the things we need to define
    
    - Actors behaviour and the message that an actor can send or receive
- To Create Behaviour
    
    Extends class AbstractBehavior

package org.example;

import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

/*
To create behavior extends AbstractBehavior and <> accepts type of message it can receive
To compile :-
    -Create constructor
    -Create createReceive :- code is going to run when we receive the message
 */
public class FirstSimpleBehavior extends AbstractBehavior<String> {
    /*
    to call the constructor we need parameter of type ActorContext, that we might not able to get
    to get --> we can use Behaviors.Setup
     */
    private FirstSimpleBehavior(ActorContext<String> context) {
        super(context);
    }
    /*
    type of behavior must be same as message type and will call this method to get an object
    of FirstSimpleBehavior type
     */
    public static Behavior<String> create(){
        //call the constructor and return the result
        //import javasdsl packages and typed also present in imports
//       return Behaviors.setup(context ->{
//            return new FirstSimpleBehavior(context);
//        });
        return Behaviors.setup(FirstSimpleBehavior::new);
    }

    @Override
    public Receive<String> createReceive() {
        // ingore any message
//        return newReceiveBuilder()
//                .build(); // present in AbstractBehavior class

        //for processing
        return newReceiveBuilder()
                .onAnyMessage(message->{
                    //code to run , this need to return something for now return this
                    System.out.println("I received the message : "+message);
                    return this;
                })
                .build();
    }
}





Custom Message Types
-----------------------
- Actors can send and receive any java class that is serialisable.
1. Main method


import akka.actor.typed.ActorSystem;

public class Main {


//    public static void main(String[] args){
//        //To instantiate the first actor in the system call ActorSystem, pick one from akka.actor.typed
//        //1- parameter is the instance of  Behavior that we want our actor to have
//        //2- parameter -> Name of actor
//        // ActorSystem<String> --> it is generic type that defines the type of messages our actor can receive
//        ActorSystem<String> actorSystem = ActorSystem.create(FirstSimpleBehavior.create(),"FirstActorSystem");
////        ActorSystem<String> actorSystem1 = ActorSystem.create(FirstSimpleBehavior.create(),"FirstActorSystem");
//        /* ActorSystem is the wrapper that will act as an entry point to Akka. Actors can create more actors
//        or child actors but will always communicate through the very first actor we create the one we called the
//        ActorSystem
//        ActorSytem = Actor with few extra features
//        * */
//        actorSystem.tell("say hello");
//        actorSystem.tell("who are you");//--->akka://FirstActorSystem/user
////        actorSystem1.tell("who are you");
//        /*Akka allows creating multiple actor systems with the same name. While it is not a recommended practice, Akka does not enforce uniqueness of actor system names. The behavior may vary depending on the specific version and configuration of Akka being used.*/
//        actorSystem.tell("Hello are you there ?");
//        actorSystem.tell("This is the second message");
//
//        /*
//        When we instantiated actorSystem we actually created an actor with name, path , message queue
//        and set of behavior(FirstBehavior.create())
//         */
//
//        /*
//        One we execute the class the application will keeps on running until we shut it down
//        why --> because our actor can receive multiple messages
//        we can stop it programmatically
//         */
//
//
//        /*
//        ActorName cannot contain spaces since it will be a part of URL
//         */
//
//        actorSystem.tell("create a child");
//    }

    public static void main(String[] args) {
        ActorSystem<ManagerBehavior.Command> bigPrimes= ActorSystem.create(ManagerBehavior.create(),"BigPrimes");
//        bigPrimes.tell("start");

        bigPrimes.tell(new ManagerBehavior.IntructionCommand("start"));
        /*
        Manager should able to receive two different object type --> not at same time
        like worker will send big integer but main enter point system will send String
        1 message from system i.e. start
        2. big integers from worker
        we have two ways -->
            object inheritance
            interfaces --> will try this
         */
    }

    /*
    Actor can receive any message that is serializable
     */

}

2. ManagerBehavior
package org.example;

import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.SortedSet;
import java.util.TreeSet;

public class ManagerBehavior extends AbstractBehavior<ManagerBehavior.Command> { // accept string message from main system and resulttype from worker behavior that's we created Command as interface

    //To have multiple types
    public interface Command extends Serializable{}
    /*
          Manager should be able to receive two different object type --> not at same time
          like worker will send big integer but main enter point system will send String
          1 message from system i.e. start
          2. big integers from worker
          we have two ways -->
              object inheritance
              interfaces --> will try this
           */
    //For system
    public static class IntructionCommand implements  Command{
        public static final long serialVersionUID = 1L;
        private String message;

        public IntructionCommand(String message) {
            this.message = message;
        }

        public String getMessage() { // for making immutable
            return message;
        }
    }

    //for worker
    public static class ResultCommand implements  Command{
        public static final long serialVersionUID = 1L;
        private BigInteger prime;

        public ResultCommand(BigInteger prime) {
            this.prime = prime;
        }

        public BigInteger getPrime() {
            return prime;
        }
    }

    public ManagerBehavior(ActorContext<Command> context) {
        super(context);
    }

    public static Behavior<Command> create(){
        return Behaviors.setup(ManagerBehavior::new);
    }

    private SortedSet<BigInteger> primes = new TreeSet<BigInteger>();
    @Override
    public Receive<Command> createReceive() {
        /*
        When we use Command as return type it could be start message from system i.e. InstructionCommand
        or could be ResultCommand from worker
         */
        return newReceiveBuilder()
                .onMessage(IntructionCommand.class,command->{
                    if(command.getMessage().equals("start")){
                        for(int i=0; i<20; i++){
                            ActorRef<WorkerBehavior.Command> actorRef=getContext().spawn(WorkerBehavior.create(),"workerBehavior_"+i);
                            actorRef.tell(new WorkerBehavior.Command("start", getContext().getSelf())); // message to worker , reference to manager
                        }
                    }
                    return this;
                })
                .onMessage(ResultCommand.class, command->{
                    primes.add(command.getPrime());
                    System.out.println("I have received "+primes.size()+" prime numbers");
                    if(primes.size() == 20){
                        primes.forEach(System.out::println);
                    }
                    return this;
                })
//                .onMessageEquals("start",()->{
//                    for(int i=0; i<10; i++){
//                       ActorRef<WorkerBehavior.Command> actorRef=getContext().spawn(WorkerBehavior.create(),"workerBehavior_"+i);
//                       actorRef.tell(new WorkerBehavior.Command("start", getContext().getSelf())); // message to worker , reference to manager
//                    }
//                    return this;
//                })
                .build();
    }
}


3. WorkerBehavior
package org.example;

import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.Random;

public class WorkerBehavior extends AbstractBehavior<WorkerBehavior.Command> {


    /*
    This must be serializable, but if we are working on same machine it doesnt matter but if we move
    to cluster then it will create problem.
     */
    public static class Command implements Serializable {
        private String message;
        private ActorRef<ManagerBehavior.Command> sender;//manager is expecting String
        private static final long serialVersionUID=1;

        //Messages should be immutable --> create getter not setters

        public Command(String message, ActorRef<ManagerBehavior.Command> sender) {
            this.message = message;
            this.sender = sender;
        }

        public String getMessage() {
            return message;
        }

        public ActorRef<ManagerBehavior.Command> getSender() {
            return sender;
        }
    }
/*
Since Worker will going to create instance of Command class hence, we need to make Command class as static
 */

    private WorkerBehavior(ActorContext<Command> context) {// Worker going to receive Command message
        super(context);
    }

    public static Behavior<Command> create(){
        return Behaviors.setup(WorkerBehavior::new);
    }
    @Override
    public Receive<Command> createReceive() {
        return newReceiveBuilder()
                .onAnyMessage(command->{
                    if(command.message.equals("start")){
                        BigInteger bigInteger = new BigInteger(2000, new Random());
                        command.getSender().tell(new ManagerBehavior.ResultCommand(bigInteger.nextProbablePrime()));
//                        System.out.println(bigInteger.nextProbablePrime());
                    }
                    return this;
                })
//                .onMessageEquals("start",()->{
//                    BigInteger bigInteger = new BigInteger(2000, new Random());
//                    System.out.println(bigInteger.nextProbablePrime());
//                    System.out.println(getContext().getSelf().path());
//                    return this;
//                })
                .build();
    }

}

MESSAGE GUARANTEES
---------------------

- Actors can send messages to each other, and a Manager actor can receive multiple messages from many Worker actors.
- This works well on a single machine, but becomes more complex when working on a cluster.
- In AKKA, messages are delivered between actors

> ****ISN’T GUARANTEED TO HAPPEN****
> 

WHAT IS GUARANTEED IS 

- Messages are delivered at most one —> can happen in cluster not on single JVM(machine)
- Messages order is guaranteed b/w two actors
    
    Actor 1 —> [1, 2, 3, 4]—> Actor 2
    
    Even 3,4 arrives then 3 will arrive earlier then 4
    

Create a problem in which worker going to get the message to create prime number twice . but what we do is we make worker like - if you have received the message first time calcuate it and store it and send beck if you receive the message again

1. Main class

```
package org.example;

import akka.actor.typed.ActorSystem;

public class Main {


//    public static void main(String[] args){
//        //To instantiate the first actor in the system call ActorSystem, pick one from akka.actor.typed
//        //1- parameter is the instance of  Behavior that we want our actor to have
//        //2- parameter -> Name of actor
//        // ActorSystem<String> --> it is generic type that defines the type of messages our actor can receive
//        ActorSystem<String> actorSystem = ActorSystem.create(FirstSimpleBehavior.create(),"FirstActorSystem");
////        ActorSystem<String> actorSystem1 = ActorSystem.create(FirstSimpleBehavior.create(),"FirstActorSystem");
//        /* ActorSystem is the wrapper that will act as an entry point to Akka. Actors can create more actors
//        or child actors but will always communicate through the very first actor we create the one we called the
//        ActorSystem
//        ActorSytem = Actor with few extra features
//        * */
//        actorSystem.tell("say hello");
//        actorSystem.tell("who are you");//--->akka://FirstActorSystem/user
////        actorSystem1.tell("who are you");
//        /*Akka allows creating multiple actor systems with the same name. While it is not a recommended practice, Akka does not enforce uniqueness of actor system names. The behavior may vary depending on the specific version and configuration of Akka being used.*/
//        actorSystem.tell("Hello are you there ?");
//        actorSystem.tell("This is the second message");
//
//        /*
//        When we instantiated actorSystem we actually created an actor with name, path , message queue
//        and set of behavior(FirstBehavior.create())
//         */
//
//        /*
//        One we execute the class the application will keeps on running until we shut it down
//        why --> because our actor can receive multiple messages
//        we can stop it programmatically
//         */
//
//
//        /*
//        ActorName cannot contain spaces since it will be a part of URL
//         */
//
//        actorSystem.tell("create a child");
//    }

    public static void main(String[] args) {
        ActorSystem<ManagerBehavior.Command> bigPrimes= ActorSystem.create(ManagerBehavior.create(),"BigPrimes");
//        bigPrimes.tell("start");

        bigPrimes.tell(new ManagerBehavior.IntructionCommand("start"));
        /*
        Manager should able to receive two different object type --> not at same time
        like worker will send big integer but main enter point system will send String
        1 message from system i.e. start
        2. big integers from worker
        we have two ways -->
            object inheritance
            interfaces --> will try this
         */
    }

    /*
    Actor can receive any message that is serializable
     */

}
```
2. ManagerBehavior
package org.example;

import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.SortedSet;
import java.util.TreeSet;

public class ManagerBehavior extends AbstractBehavior<ManagerBehavior.Command> { // accept string message from main system and resulttype from worker behavior that's we created Command as interface

    //To have multiple types
    public interface Command extends Serializable{}
    /*
          Manager should be able to receive two different object type --> not at same time
          like worker will send big integer but main enter point system will send String
          1 message from system i.e. start
          2. big integers from worker
          we have two ways -->
              object inheritance
              interfaces --> will try this
           */
    //For system
    public static class IntructionCommand implements  Command{
        public static final long serialVersionUID = 1L;
        private String message;

        public IntructionCommand(String message) {
            this.message = message;
        }

        public String getMessage() { // for making immutable
            return message;
        }
    }

    //for worker
    public static class ResultCommand implements  Command{
        public static final long serialVersionUID = 1L;
        private BigInteger prime;

        public ResultCommand(BigInteger prime) {
            this.prime = prime;
        }

        public BigInteger getPrime() {
            return prime;
        }
    }

    public ManagerBehavior(ActorContext<Command> context) {
        super(context);
    }

    public static Behavior<Command> create(){
        return Behaviors.setup(ManagerBehavior::new);
    }

    private SortedSet<BigInteger> primes = new TreeSet<BigInteger>();
    @Override
    public Receive<Command> createReceive() {
        /*
        When we use Command as return type it could be start message from system i.e. InstructionCommand
        or could be ResultCommand from worker
         */
        return newReceiveBuilder()
                .onMessage(IntructionCommand.class,command->{
                    if(command.getMessage().equals("start")){
                        for(int i=0; i<20; i++){
                            ActorRef<WorkerBehavior.Command> worker=getContext().spawn(WorkerBehavior.create(),"workerBehavior_"+i);
                            worker.tell(new WorkerBehavior.Command("start", getContext().getSelf())); // message to worker , reference to manager
                            worker.tell(new WorkerBehavior.Command("start", getContext().getSelf()));
                        }
                    }
                    return this;
                })
                .onMessage(ResultCommand.class, command->{
                    primes.add(command.getPrime());
                    System.out.println("I have received "+primes.size()+" prime numbers");
                    if(primes.size() == 20){
                        /*
                        when we call worker twice it will print the number twice
                        since when it is going to become 20 in count at that time too
                        two messages will be send and for first 20th message worker
                        will calculate the number and return it back and then it will print the numbers
                        (all 20) on second message(duplicate 20) it will just return one calculated previously
                        but still print all the prime number since count is still 20.
                         */
                        primes.forEach(System.out::println);
                    }
                    return this;
                })
//                .onMessageEquals("start",()->{
//                    for(int i=0; i<10; i++){
//                       ActorRef<WorkerBehavior.Command> actorRef=getContext().spawn(WorkerBehavior.create(),"workerBehavior_"+i);
//                       actorRef.tell(new WorkerBehavior.Command("start", getContext().getSelf())); // message to worker , reference to manager
//                    }
//                    return this;
//                })
                .build();
    }
}

3.WorkerBehavior
package org.example;

import akka.actor.typed.ActorRef;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.Random;

public class WorkerBehavior extends AbstractBehavior<WorkerBehavior.Command> {


    /*
    This must be serializable, but if we are working on same machine it doesnt matter but if we move
    to cluster then it will create problem.
     */
    public static class Command implements Serializable {
        private String message;
        private ActorRef<ManagerBehavior.Command> sender;//manager is expecting String
        private static final long serialVersionUID=1;

        //Messages should be immutable --> create getter not setters

        public Command(String message, ActorRef<ManagerBehavior.Command> sender) {
            this.message = message;
            this.sender = sender;
        }

        public String getMessage() {
            return message;
        }

        public ActorRef<ManagerBehavior.Command> getSender() {
            return sender;
        }
    }
/*
Since Worker will going to create instance of Command class hence, we need to make Command class as static
 */

    private WorkerBehavior(ActorContext<Command> context) {// Worker going to receive Command message
        super(context);
    }

    public static Behavior<Command> create(){
        return Behaviors.setup(WorkerBehavior::new);
    }

    private BigInteger prime;
    @Override
    public Receive<Command> createReceive() {
        return newReceiveBuilder()
                .onAnyMessage(command->{
                    if(command.message.equals("start")){
                        if(prime == null) {// first time it will calculate next time it will send back the same
                            BigInteger bigInteger = new BigInteger(2000, new Random());
                            prime = bigInteger.nextProbablePrime();
                        }
                        command.getSender().tell(new ManagerBehavior.ResultCommand(prime));
//                        System.out.println(bigInteger.nextProbablePrime());
                    }
                    return this;
                })
//                .onMessageEquals("start",()->{
//                    BigInteger bigInteger = new BigInteger(2000, new Random());
//                    System.out.println(bigInteger.nextProbablePrime());
//                    System.out.println(getContext().getSelf().path());
//                    return this;
//                })
                .build();
    }

}

